#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck source=/dev/null

export TERM=${TERM:-xterm}
export TERM=${TERM:-xterm-256color}

# Defining color variables (bold only)
export black="\033[1;30m"
export red="\033[1;31m"
export green="\033[1;32m"
export yellow="\033[1;33m"
export blue="\033[1;34m"
export magenta="\033[1;35m"
export cyan="\033[1;36m"
export white="\033[1;37m"
#
export COL_NC='\e[0m' # No Color
export COL_LIGHT_GREEN='\e[1;32m'
export COL_LIGHT_RED='\e[1;31m'
export TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
export CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}${white}]"
export INFO="[i]"
export DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
export OVER="\\r\\033[K"
export DOTPREFIX="  ${black}::${reset} "

# Setting variables for bold and reset
export bold="\033[1m"
export reset="\033[0m"
declare IS_UPGRADE=false
declare DM='lightdm'
declare WM='openbox'
declare pkgname=comm-"${WM}"
declare servicesToEnable=("${DM}" sshd bluetooth)
declare servicesToDisable=()

msg() {
	local msg="$1"
	echo -e "${green}==>[${pkgname}] ${bold}${yellow}${msg}${reset}" >&2
}

log_ok() {  echo -e "  ${TICK} ${*}${reset}"; }
log_err() { echo -e "  ${CROSS} ${*}${reset}"; }

die() {
	local msg=$1
	shift
	#printf "  %b %s\\n" "${CROSS}" "${red}${msg}${reset}"
	echo -e "  ${CROSS} ${red}${msg}${reset}"
  sh_restoring_lock
	exit 1
}

sh_load_optdepends() {
	local info_file="/usr/share/${pkgname}/optdepends"

	if [[ -f "$info_file" && -r "$info_file" ]]; then
		mapfile -t OPTDEPENDS <"$info_file"
	else
		msg "${red}FATAL: Something went wrong! File '$info_file' not found or without read permission."
		msg "${red}FATAL: Something went wrong! File '$info_file' not found or without read permission."
	fi
}

sh_restoring_lock() {
  msg "Restauring pacman lock: /var/lib/pacman/db.lck"
  touch /var/lib/pacman/db.lck &>/dev/null
}

sh_check_package_exist() {
	local pkg
	for pkg in "${OPTDEPENDS[@]}"; do
    if ! pacman -Qs "$pkg" &>/dev/null; then
  		if ! pacman -Ss "^$pkg$" &>/dev/null; then
	  	  die "Fatal: package '$pkg' not exist in repo"
		  fi
		fi
    log_ok "Check: ${cyan}$pkg"
  done
}

sh_start_dbus_in_chroot() {
	# Verifica se o D-Bus já está em execução
	if ! pgrep -x "dbus-daemon" >/dev/null; then
		# Cria o diretório para o socket do D-Bus
		mkdir -p /run/dbus
		chmod 755 /run/dbus

		# Inicia o D-Bus
		dbus-daemon --system --fork

		# Configura as variáveis de ambiente
		export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/dbus/system_bus_socket
		export DBUS_SYSTEM_BUS_ADDRESS=unix:path=/run/dbus/system_bus_socket
	fi
}

post_install() {
	msg "Initializing system installation and configuration..."

	sh_load_optdepends

	[[ -e /etc/environment ]] && source /etc/environment
	: "${IN_CHROOT_INSTALLER:=false}"
	: "${IN_CHROOT_INSTALLER_USER:=root}"

	if $IN_CHROOT_INSTALLER; then
		# sh_start_dbus_in_chroot
		:
	fi

	if [[ -f /var/lib/pacman/db.lck ]]; then
		msg "Removing pacman lock: /var/lib/pacman/db.lck"
		rm -f /var/lib/pacman/db.lck &>/dev/null
	fi

	# Common packages for all GPUs
	COMMON_PACKAGES=(
		mhwd-biglinux
		mesa
		lib32-mesa
		vulkan-mesa-layers
		lib32-vulkan-mesa-layers
	)

	synchronizing_database() {
		pacman -Syu --quiet --noconfirm &>/dev/null
	}

	install_packages() {
		pacman -S --quiet --noconfirm --needed --overwrite \* "$@" &>/dev/null
	}

	msg "Please wait, synchronizing databases..."
	synchronizing_database

	msg "Installing common packages: ${COMMON_PACKAGES[*]}"
	install_packages "${COMMON_PACKAGES[@]}"

	msg "Checking for the existence of packages..."
	sh_check_package_exist

	msg "Installing optdepends packages: ${OPTDEPENDS[*]}"
	install_packages "${OPTDEPENDS[@]}"

	msg "Detecting GPU and installing appropriate drivers..."
	GPU_INFO=$(lspci -nnk | grep -A3 -E "VGA|3D|Display")

	if grep -qiw "NVIDIA" <<<"$GPU_INFO"; then
		msg "NVIDIA detected! Installing drivers..."

		msg "Detect kernel version and set package name"
		KERNEL_VERSION=$(uname -r | cut -d '.' -f1,2 | tr -d '.')
		KERNEL_PACKAGE="linux${KERNEL_VERSION}-nvidia"

		msg "Detected kernel: $KERNEL_VERSION"
		msg "Installing NVIDIA packages: $KERNEL_PACKAGE nvidia-utils nvidia-settings"
		install_packages "$KERNEL_PACKAGE" nvidia-utils nvidia-settings

		msg "Blacklisting Nouveau..."
		{ 
		echo -e "blacklist nouveau\ninstall nouveau /bin/true" > /etc/modprobe.d/nouveau.conf
		echo -e "blacklist nouveau\ninstall nouveau /bin/true" > /etc/modprobe.d/blacklist.conf
		} >/dev/null 2>&1
EOF
	elif grep -qiw "Intel" <<<"$GPU_INFO"; then
		msg "Intel GPU detected! Installing drivers..."
		install_packages vulkan-intel lib32-vulkan-intel
		:
	elif grep -qEiw "AMD|ATI" <<<"$GPU_INFO"; then
		msg "AMD/ATI GPU detected! Installing drivers..."
		install_packages mesa-utils \
			vulkan-icd-loader lib32-vulkan-icd-loader \
			vulkan-headers vulkan-radeon lib32-vulkan-radeon \
			mhwd-amdgpu mhwd-ati
		:
	else
		msg "${yellow}Warning: No compatible GPU detected. Skipping driver installation.${reset}"
	fi

	msg "Create the ${DM^} user if it doesn't exist"
	if ! id "${DM}" >/dev/null; then
		msg "Creating ${DM^} user..."
		useradd -r -s /usr/bin/nologin -M -d /var/lib/${DM} ${DM} &>/dev/null
	else
		msg "${DM^} user already exists, skipping creation."
	fi

	msg "Setting up ${DM^} directory..."
	mkdir -p /var/lib/${DM} >/dev/null
	chown -R ${DM}:${DM} /var/lib/${DM} >/dev/null

	msg "Setting up user..."
	user=$(awk -F: '$3 >= 1000 && $3 < 65000 { print $1; exit }' /etc/passwd)
	if $IN_CHROOT_INSTALLER; then
		if [[ -n $IN_CHROOT_INSTALLER_USER || $IN_CHROOT_INSTALLER_USER != 'root' ]]; then
			user=$IN_CHROOT_INSTALLER_USER
		fi
	fi
	user_home=$(getent passwd "$user" | cut -d: -f6)

	msg "Copying skel to $user_home..."
	mkdir -p "$user_home" &>/dev/null
	cp -Rfpa /etc/skel/. "$user_home/" &>/dev/null

	# Ensure necessary directories exist
	mkdir -p "$user_home/.backup" "$user_home/.config" &>/dev/null
	chown "$user:$user" "$user_home/.backup" "$user_home/.config" &>/dev/null
	
	for file in .bashrc; do
		if [[ -e "$user_home/$file" ]] && [[ ! -L "$user_home/$file" ]]; then
			msg "Backing up existing $file..."
			mv "$user_home/$file" "$user_home/.backup/$file" >/dev/null
		fi
	done
	mv -f "$user_home/.config/.bashrc.pacnew" "$user_home/.bashrc" &>/dev/null
	chown -h "$user:$user" "$user_home/.bashrc" >/dev/null

	msg "Setting user folder permissions in ${user_home}"
	chown -R "$user:$user" "$user_home" &>/dev/null

	#Change lightdm config
	if [[ -f /etc/lightdm/slick-greeter.conf ]]; then
		msg "Existing /etc/lightdm/slick-greeter.conf found. Creating a backup at /etc/lightdm/slick-greeter.conf.bak .."
		mv -f /etc/lightdm/slick-greeter.conf /etc/lightdm/slick-greeter.conf.bak >/dev/null
		msg "Applying new lightdm configuration..."
		mv -f /etc/lightdm/slick-greeter.conf.pacnew /etc/lightdm/slick-greeter.conf >/dev/null
	elif [[ -f /etc/lightdm/slick-greeter.conf.pacnew ]]; then
		msg "No existing lightdm configuration found. Using default settings..."
		mv -f /etc/lightdm/slick-greeter.conf.pacnew /etc/lightdm/slick-greeter.conf >/dev/null
	fi

	# Apply wallpaper using Pywal

	if command -v wal &>/dev/null; then
		msg "Applying wallpaper using Pywal for user: $user"
		sudo -u "$user" wal -i /usr/share/backgrounds/community/ob_008.jpg &>/dev/null
	else
		msg "${yellow}Warning: 'wal' command not found. Skipping wallpaper setup.${reset}"
	fi

	if command -v nautilus >/dev/null; then
		msg "Configuring Nautilus..."
		if glib-compile-schemas /usr/share/glib-2.0/schemas/; then
			msg "Nautilus schemas compiled successfully!"
		else
			msg "${yellow}Warning: Failed to compile Nautilus schemas. Some features may not work correctly.${reset}"
		fi
	fi

	if ! $IS_UPGRADE; then
		msg "Enabling ${DM^}..."
		if ! systemctl enable ${DM} &>/dev/null; then
			msg "${red}Error: It went wrong when activating ${DM^}"
		fi
	fi

	for service in "${servicesToDisable[@]}"; do
		if systemctl is-active --quiet "${service}"; then
			msg "Disabling service ${service}..."
			if ! systemctl disable "${service}" &>/dev/null; then
				msg "${red}Error: It went wrong when desactivating service ${service}"
			fi
		else
			msg "${green}Service ${service} is already inactive..."
			continue
		fi
	done

	for service in "${servicesToEnable[@]}"; do
		if systemctl is-active --quiet "${service}"; then
			msg "${green}Service ${service} is already active..."
			continue
		else
			if ! systemctl enable "${service}" &>/dev/null; then
				msg "${red}Error: It went wrong when activating service ${service}"
			fi
		fi
	done

	if ! $IN_CHROOT_INSTALLER; then
		if ! $IS_UPGRADE; then
			msg "Please wait, Generating initramfs for all kernels..."
			mkinitcpio -P &>/dev/null
		fi

		msg "Configuring GRUB..."
		# Change GRUB config
		if ! grep -qi "${WM}" /etc/default/grub; then
			sed -i "s/^GRUB_DISTRIBUTOR=\"\(.*\)\"/GRUB_DISTRIBUTOR=\"\1 ${WM^}\"/" /etc/default/grub
		fi
		sed -i 's|^GRUB_CMDLINE_LINUX_DEFAULT=.*|GRUB_CMDLINE_LINUX_DEFAULT="quiet splash plymouth.enable=1 loglevel=4 libata.noacpi=1 acpi=force apm=power-off nowatchdog tsc=nowatchdog cryptomgr.notests no_timer_check rcupdate.rcu_expedited=1 intel_pstate=active amd_pstate=active cpuidle.governor=teo split_lock_detect=off clearcpuid=514 transparent_hugepage=never skew_tick=1 intremap=off nosoftlockup audit=0 nomce systemd.show_status=auto rd.udev.log_level=3 apparmor=1 security=apparmor vconsole.font=Uni2-Fixed16 intel_iommu=on amd_iommu=on tdx=on nvme_load=yes nouveau.modeset=1 i915.modeset=1 amdgpu.modeset=1 radeon.si_support=0 radeon.cik_support=0 amdgpu.si_support=1 amdgpu.cik_support=1 nvidia.modeset=1 nvidia_drm.modeset=1 DEEPIN_GFXMODE="|' /etc/default/grub 1>/dev/null

		msg "Generating GRUB configuration files..."
		update-grub &>/dev/null
	fi

  # Restauring pacman lock: /var/lib/pacman/db.lck
  sh_restoring_lock
  
	if ! $IS_UPGRADE; then
		msg "Installation complete. Rebooting in 10 seconds..."
		# Countdown before reboot
		for i in $(seq 10 -1 1); do
			printf "%d..." "$i"
			sleep 1
		done
		echo
		msg "Rebooting now..."
		reboot
	else
		msg "Upgrade complete."
	fi
	
}

post_remove() {
	msg "Removing symlinks and restoring backups..."
	user=$(awk -F: '$3 >= 1000 && $3 < 65000 { print $1; exit }' /etc/passwd)
	user_home=$(getent passwd "$user" | cut -d: -f6)

	# Restore home directory files
	for file in .bashrc; do
		if [[ -L "$user_home/$file" ]]; then
			rm "$user_home/$file" >/dev/null
			[[ -e "$user_home/.backup/$file" ]] && {
				mv -f "$user_home/.backup/$file" "$user_home/$file"
			}
		fi
	done
	.bashrc
}

post_upgrade() {
	IS_UPGRADE=true
	post_install
}
